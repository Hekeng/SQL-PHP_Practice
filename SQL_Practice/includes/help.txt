Поиск элементов

Методы:

document.querySelector(selector) – возвращает первый элемент, который совпадает с селектором.

document.querySelectorAll(selector) – возвращает NodeList всех элементов по селектору.

Что принимают: строку селектора (класс, id, тег или атрибут [data-*]).

Что отдают: элемент или коллекцию элементов.

Используем для: собрать кнопки, окна, элементы с data-action или data-target.

2️⃣ Чтение/запись data-атрибутов

Свойства/методы:

element.dataset – объект всех data-* атрибутов элемента.

Пример: element.dataset.action → вернёт значение data-action.

Можно присвоить: element.dataset.target = "auth-overlay".

Что принимают/отдают: строки, возвращает строки.

Используем для: понять, что нужно сделать при клике, и на какой элемент действовать.

3️⃣ Обработка событий

Методы:

element.addEventListener(eventType, callback) – привязывает обработчик.

Что принимают: тип события (click, input, submit) и функцию-обработчик.

Что отдают: ничего, просто ставит слушатель.

Используем для: реагировать на клики по кнопкам и открывать/закрывать окна.

4️⃣ Манипуляция классами

Свойства/методы:

element.classList.add("className") – добавляет класс.

element.classList.remove("className") – убирает класс.

element.classList.toggle("className") – переключает класс.

element.classList.contains("className") – проверяет наличие класса.

Что принимают/отдают: строку, возвращают булево (для contains).

Используем для: показывать/скрывать окна (.is-hiden, .is-none).

5️⃣ Манипуляция стилями

Свойства:

element.style.property = value – напрямую задаёт CSS.

getComputedStyle(element).property – получает текущий стиль.

Что принимают/отдают: строки CSS-значений.

Используем для: динамически менять видимость, размеры или позицию, если нужно.

6️⃣ Навигация по DOM

Свойства/методы:

element.parentElement – родитель.

element.children – коллекция дочерних элементов.

element.closest(selector) – находит ближайший родитель, который подходит под селектор.

Что принимают/отдают: селектор для closest, возвращают элемент или коллекцию.

Используем для: найти окно по кнопке, понять в каком контейнере мы находимся.

7️⃣ Состояние и хранение

Идея:

Можно хранить активное окно в переменной (let currentWindow = ...), чтобы знать, что закрывать перед открытием нового.

dataset сам по себе не хранит состояние, только метки.

Что используем: объект с ключами (например, windows["auth-overlay"] = element) или переменную для активного окна.

8️⃣ Логика открытия/закрытия

Пример концепта (словесно):

Слушатель клика на кнопку.

Читаем data-action и data-target.

Находим целевой элемент по data-target.

Если action = "open" → показываем окно (удаляем .is-hiden или .is-none).

Если action = "close" → скрываем окно (добавляем .is-hiden или .is-none).

Можно проверять текущее состояние через .classList.contains().

9️⃣ Универсальный метод

Можно иметь одну функцию, которая принимает событие:

Проверяет наличие data-action.

Определяет data-target.

Находит элемент через querySelector("[data-panel='…']") или по id.

Выполняет действие (открыть/закрыть/переключить).

Таким образом, не важно сколько кнопок и окон — логика единая